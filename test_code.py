r"""
Tests for the code files.

Functions to automatically call ``pytest``.
"""


import numpy as np
from oracle import Oracle
from uncertainty import BudgetUncertaintySet, CertaintySet, EllipsoidalUncertaintySet, CustomizedUncertaintySet
from dualsubgradient import dualSubgradient
from tools import maxGrad, gradient
import warnings
warnings.filterwarnings('ignore', category=UserWarning)


def test_oracle():
    r"""
    Function asserts the result from ``oracle()``.

    Returns
    -------
    None.
    """
    abar = np.array([0.2000, 0.1875, 0.1625, 0.1500], dtype=float)
    n = len(abar)
    cs = (30 * np.ones(n, dtype=float))
    ds = (1000 * np.ones(n, dtype=float))
    ps = (0.1 * np.array([1.10, 0.85, 0.90, 0.80], dtype=float))
    B = 1.0
    eps = 0.0001

    abar = abar * (1.0 - np.array([0.05390, 0.74720, 0.02590, 0.17300], dtype=float))

    fval, x = Oracle(eps, abar, cs, ds, ps, B).solve(display=True)

    expect_fval = 0.05261329356026702
    # expect_x = np.array([0.017715505600, 0.000479657947, 11.086796900000, 0.002083670990], dtype=float)

    assert np.round(fval, 4) == np.round(expect_fval, 4)
    # assert np.array_equal(np.round(x, 4), np.round(expect_x, 4))


def test_ellipsoidal_set():
    r"""
    Function asserts the results generated by ``EllipsoidalUncertaintySet()``.

    Returns
    -------
    None.
    """
    size = 2
    rho = 1.0
    store = 10
    Z_set = EllipsoidalUncertaintySet(size=size, rho=rho, n_store=store)

    is_feasible = []
    diam = []
    z0_1 = Z_set.store[0]
    for _ in range(store):
        z = Z_set.get()
        is_feasible.append(int(Z_set.feasible(z)))
        diam.append(np.linalg.norm(z, 2))
    assert (np.sum(is_feasible, dtype=int) == store)
    assert (np.all(np.array(diam, dtype=float) <= 1.0))

    z0_2 = Z_set.get()
    assert (not np.array_equal(z0_1, z0_2))

    z0 = np.array([2.0, 3.0])
    z = Z_set.project(z0)
    assert (np.linalg.norm(z, 2) == 1.0)


def test_budgeted_set():
    r"""
    Function asserts the results generated by ``BudgetUncertaintySet()``.

    Returns
    -------
    None.
    """
    size = 10
    Gamma = 2.0
    store = 10
    Z_set = BudgetUncertaintySet(size=size, Gamma=Gamma, half=True, n_store=store)

    assert (np.round(Z_set.diam(), 9) == 2.0)

    # check realizations
    z0_1 = Z_set.store[0]
    for _ in range(50):
        z = Z_set.get()
    assert (not np.array_equal(z0_1, Z_set.store[0]))

    # z0 is outside uncertainty set
    z0 = np.ones(size)
    z = Z_set.project(z0)
    assert (Z_set.feasible(z))

    # z0 is inside
    z0 = np.zeros(size)
    z = Z_set.project(z0)
    assert (Z_set.feasible(z))

    # z0 is inside
    z0 = Z_set.get()
    z = Z_set.project(z0)
    assert (Z_set.feasible(z))


def test_customized_set():
    r"""
    Function asserts the results generated by ``CustomizedUncertaintySet()``.

    Returns
    -------
    None.
    """
    size = 10
    rho = 1.0
    store = 10
    Z_set = CustomizedUncertaintySet(size=size, rho=rho, n_store=store)

    # check realizations
    z0_1 = Z_set.store[0]
    for _ in range(50):
        z = Z_set.get()
    assert (not np.array_equal(z0_1, Z_set.store[0]))

    # z0 is outside uncertainty set
    z0 = np.ones(size)
    z = Z_set.project(z0)
    assert (Z_set.feasible(z))

    # z0 is inside
    z0 = np.zeros(size)
    z = Z_set.project(z0)
    assert (Z_set.feasible(z))

    # z0 is inside
    z0 = Z_set.get()
    z = Z_set.project(z0)
    assert (Z_set.feasible(z))


def test_maxGrad():
    r"""
    Function asserts the results generated by ``maxGrad()``.

    Returns
    -------
    None.
    """
    size = 4
    abar = np.array([0.20000, 0.18750, 0.16250, 0.15000], dtype=float)
    cs = (30.0 * np.ones(size))
    ds = (1000.0 * np.ones(size))
    ps = (0.1 * np.array([1.100, 0.850, 0.900, 0.800], dtype=float))
    B = 1.0

    assert(np.round(maxGrad(abar, cs, ds, ps, B), 3) == np.round(0.37334527424444053, 3))


def test_gradient():
    r"""
    Function asserts the results generated by ``gradient()``.

    Returns
    -------
    None.
    """
    size = 4
    abar = np.array([0.20000, 0.18750, 0.16250, 0.15000], dtype=float)
    cs = (30.0 * np.ones(size))
    ds = (1000.0 * np.ones(size))
    xs = np.ones(size, dtype=float)

    expected = np.array([0.029991, 0.02999063, 0.02998988, 0.02998951], dtype=float)

    assert(np.array_equal(np.round(gradient(abar, cs, ds, xs), 3), np.round(expected, 3)))


def test_dual_sub_grad():
    r"""
    Function asserts the results generated by ``dualSubgradient()``.

    Returns
    -------
    None.
    """
    size = 4
    abar = np.array([0.20000, 0.18750, 0.16250, 0.15000], dtype=float)
    cs = (30.0 * np.ones(size))
    ds = (1000.0 * np.ones(size))
    ps = (0.1 * np.array([1.100, 0.850, 0.900, 0.800], dtype=float))
    B = 1.0
    Gamma = 1.0
    eps = 1e-6

    U = BudgetUncertaintySet(size, Gamma, half=True)

    fval, x = dualSubgradient(eps, U, abar, cs, ds, ps, B, display=False, earlystop=False, itermax=200)
    # print(fval, np.round(x, 4))
    assert (np.round(fval, 3) == 0.054)
